## SA1130

<table>
<tr>
  <td>TypeName</td>
  <td>SA1130UseLambdaSyntax</td>
</tr>
<tr>
  <td>CheckId</td>
  <td>SA1130</td>
</tr>
<tr>
  <td>Категория</td>
  <td>Правила удобочитаемости</td>
</tr>
</table>

:memo: Это правило является новым для **StyleCop Analyzers**, и его не было в **StyleCop Classic**.

## Причина

Анонимный метод был объявлен с использованием формы `delegate (параметры) { }`, когда лямбда-выражение обеспечило бы эквивалентное поведение с синтаксисом `(параметры) => { }`.

## Описание правила

Нарушение этого правила происходит всякий раз, когда код содержит анонимный метод, использующий "старый" стиль `delegate (parameters) { }`.

Например, каждое из следующих действий приведет к нарушению этого правила:

```csharp
Action a = delegate { x = 0; };
Action b = delegate() { y = 0; };
Func<int, int, int> c = delegate(int m, int n) { return m + n; }
```

В следующем коде показаны эквивалентные объявления переменных с использованием более привычного лямбда-синтаксиса.

```csharp
Action a = () => { x = 0; };
Action b = () => { y = 0; };
Func<int, int, int> c = (m, n) => m + n;
```

:memo: Не всегда можно заменить анонимный метод эквивалентным лямбда-выражением. Например, следующий код не приведет к нарушению этого правила, поскольку анонимный метод и лямбда-выражение имеют разную семантику.

```csharp
var x = A(() => { }); // Expression
var y = A(delegate { }); // Action

private Expression<Action> A(Expression<Action> expression)
{
    return expression;
}

private Action A(Action action)
{
    return action;
}
```

## Как исправить нарушения

Чтобы исправить нарушение этого правила, замените анонимную функцию эквивалентным лямбда-выражением.

## Как подавить нарушения
```csharp
#pragma warning disable SA1130 // Используйте лямбда-синтаксис
Action a = delegate { x = 0; }
#pragma warning restore SA1130 // Используйте лямбда-синтаксис
```