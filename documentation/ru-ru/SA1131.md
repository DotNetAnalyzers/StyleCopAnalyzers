## SA1131

<table>
<tr>
  <td>TypeName</td>
  <td>SA1131UseReadableConditions</td>
</tr>
<tr>
  <td>CheckId</td>
  <td>SA1131</td>
</tr>
<tr>
  <td> атегори€</td>
  <td>ѕравила удобочитаемости</td>
</tr>
</table>

:memo: Ёто правило €вл€етс€ новым дл€ **StyleCop Analyzers**, и его не было в **StyleCop Classic**.

## ѕричина

—равнение было произведено между переменной и литеральным значением или константой, и переменна€ оказалась в правой части выражени€.

## ќписание правила

Ќарушение этого правила происходит в том случае, если код содержит сравнение между литеральным значением или константой и значением переменной, и переменна€ оказалась в правой части выражени€.

Ќапример, в следующем коде показан один из часто встречающихс€ случаев:

```csharp
public void Method(string value)
{
    if (null == value) // SA1131
    {
        throw new ArgumentNullException(nameof(value));
    }
}
```

«десь под *литеральным или константным значением* понимаетс€ любое из следующих:

* „исловой литерал, такой как `1`, `0.0f` или `5.0m`
* —троковый литерал
* `null`
* `default(T)` (дл€ любого типа `T`)
* Ћюбое выражение, которое оцениваетс€ в посто€нное значение во врем€ компил€ции
* —сылка на `static readonly` поле, такое как `IntPtr.Zero`.

«начение *переменной* - это любое выражение, которое не считаетс€ литералом или константным значением.

*—равнение* - это бинарное выражение, использующее один из следующих операторов.

* `==`
* `!=`
* `<`
* `>`
* `<=`
* `>=`

##  ак исправить нарушение

„тобы исправить нарушение этого правила, измените пор€док следовани€ операндов при сравнении.

##  ак подавить нарушени€

```csharp
public void Method(string value)
{
#pragma warning disable SA1131 // »спользуйте читаемые услови€
    if (null == value)
#pragma warning restore SA1131 // »спользуйте читаемые услови€
    {
        throw new ArgumentNullException(nameof(value));
    }
}
```