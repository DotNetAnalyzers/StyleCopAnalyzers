## SA1129

<table>
<tr>
  <td>TypeName</td>
  <td>SA1129DoNotUseDefaultValueTypeConstructor</td>
</tr>
<tr>
  <td>CheckId</td>
  <td>SA1129</td>
</tr>
<tr>
  <td>Категория</td>
  <td>Правила удобочитаемости</td>
</tr>
</table>

:memo: Это правило является новым для **StyleCop Analyzers**, и его не было в **StyleCop Classic**.

## Причина

Тип значений был создан с использованием синтаксиса `new T()`.

## Описание правила

Нарушение этого правила происходит, когда тип значения `T` построен с использованием синтаксиса `new T()`. Чтобы создать экземпляр типа значения по умолчанию, используйте вместо этого эквивалентный синтаксис `default(T)`.

Например, следующий код приведет к нарушению этого правила:

```csharp
ImmutableArray<int> array = new ImmutableArray<int>();
```

Несмотря на то, что вышеприведенный код создает новый неизменяемый массив, готовый к использованию, в действительности переменной `array` был присвоен экземпляр по умолчанию `ImmutableArray<int>`, и почти любая попытка использовать переменную приведет к `NullReferenceException`. Чтобы избежать путаницы с поведением ссылочных типов, экземпляры по умолчанию для типов значений всегда следует создавать с помощью синтаксиса `default(T)`.

> :memo: Это предложение относится только к различию между `default(T)` и `new T()`. Другие значения по умолчанию, включая `CancellationToken.None`, `0`, `0.0f`, `IntPtr.Zero` и `RegexOptions.None`, *не* будут выдавать предупреждение.

## Как исправить нарушения

Чтобы исправить нарушение этого правила, замените синтаксис `new T()` на эквивалентный синтаксис `default(T)`.

## Как подавить нарушения

```csharp
#pragma warning disable SA1129 // Не используйте конструктор типов значений по умолчанию
IntPtr zero = new IntPtr();
#pragma warning restore SA1129 // Не используйте конструктор типов значений по умолчанию
```
